{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"certs/","title":"Certs","text":"<p>Instructions to create a CSR(Certificate Signing Request)</p>"},{"location":"certs/#_1","title":"Certs","text":"<p>$ openssl req -new -sha256 -days 730 -newkey rsa:2048 -keyout privatekey.txt -out snteks-cert.csr Generating a 2048 bit RSA private key .....+++ .....................................+++ writing new private key to 'privatekey.txt' Enter PEM pass phrase: ()  Very important to save the passphrase here Verifying - Enter PEM pass phrase: Verify failure Enter PEM pass phrase: Verifying - Enter PEM pass phrase:</p> <p>You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank.</p>"},{"location":"docker/","title":"Docker","text":"<p>Command to check status of docker deamon   sudo systemctl status docker</p> <p>Command to stop docker deamon   sudo systemctl stop docker</p>"},{"location":"kubernetes/certification_prep/","title":"Back and restore","text":"<pre><code>back and restore resources\n\nback and restore etcd\n</code></pre>"},{"location":"kubernetes/dockerCMDs/","title":"connect to docker","text":"<p>docker login --username AWS --password $(aws ecr get-login-password --region us-east-1) accountNumber.dkr.ecr.us-east-1.amazonaws.com</p>"},{"location":"kubernetes/dockerCMDs/#pull-image-from-image-repository","title":"pull Image from image repository","text":"<p>docker pull account.dkr.ecr.us-east-1.amazonaws.com/image:tag</p>"},{"location":"kubernetes/dockerCMDs/#remove-image-from-docker","title":"remove image from docker","text":"<p>docker rmi image:tag</p>"},{"location":"kubernetes/dockerCMDs/#docker-tag","title":"docker tag","text":"<p>docker tag source_account.dkr.ecr.us-east-1.amazonaws.com/image:tag dest_account.dkr.ecr.us-east-1.amazonaws.com/image:tag</p>"},{"location":"kubernetes/dockerCMDs/#docker-push","title":"docker push","text":"<p>docker push dest_account.dkr.ecr.us-east-1.amazonaws.com/image:tag</p>"},{"location":"kubernetes/eks%20challenges/","title":"Eks challenges","text":""},{"location":"kubernetes/eks%20challenges/#1-why-does-it-take-long-time-to-pull-image-on-a-fargate-pod","title":"1. Why does it take long time to pull image on a fargate pod","text":"<pre><code>Fargate does not cache images, and therefore the whole image is pulled from the registry when a task runs. The following are our recommendations for images used for Fargate tasks:\n\nUse a larger task size with additional vCPUs. The larger task size can help reduce the time that is required to extract the image when a task launches.\nUse a smaller base image.\nHave the repository that stores the image in the same Region as the task.\n</code></pre>"},{"location":"kubernetes/eks%20challenges/#2-failed-to-provision-eks-for-the-first-time-error-role-with-arn-could-not-be-assumed-because-it-does-not-exist-or-the-trusted-entity-is-not-correct","title":"2. Failed to provision EKS for the first time Error: \"Role with arn: , could not be assumed because it does not exist or the trusted entity is not correct\"*","text":"<pre><code>AWSServiceRoleForAmazonEKS and AWSServiceRoleForAmazonEKSForFargate roles `MUST` be enabled to provision infrastructure via terraform and crossplane\n</code></pre>"},{"location":"semver/semantic-release/","title":"Semantic Versioning","text":""},{"location":"semver/semantic-release/#introduction-to-semantic-versioning","title":"Introduction to Semantic Versioning","text":"<p>Semantic versioning (also known as SemVer) is a versioning system that has been on the rise over the last few years. It has always been a problem for software developers, release managers and consumers. Having a universal way of versioning the software development projects is the best way to track what is going on with the software as new plugins, addons, libraries and extensions are being built almost every day. This problem can be solved by Semantic Versioning. In brief, it\u2019s a way for numbering the software releases.</p> <p>So, SemVer is in the form of Major.Minor.Patch</p> <p></p> <p>Semantic Versioning is a 3-component number in the format of X.Y.Z, where :</p> <ul> <li>X stands for a major version. The leftmost number denotes a major version. When you increase the major version number, you increase it by one but you reset both patch version and minor versions to zero. If the current version is 2.6.9 then the next upgrade for a major version will be 3.0.0. Increase the value of X when breaking the existing API.</li> <li>Y stands for a minor version. It is used for the release of new functionality in the system. When you increase the minor version, you increase it by one but you must reset the patch version to zero. If the current version is 2.6.9 then the next upgrade for a minor version will be 2.7.0. Increase the value of Y when implementing new features in a backward-compatible way.</li> <li>Z stands for a Patch Versions: Versions for patches are used for bug fixes. There are no functionality changes in the patch version upgrades. If the current version is 2.6.9 then the next version for a patch upgrade will be 2.6.10. There is no limit to these numbers. Increase the value of Z when fixing bugs Valid identifiers are in the set [A-Za-z0-9] and cannot be empty. Pre-release metadata is identified by appending a hyphen to the end of the SemVer sequence. Thus a pre-release for version 1.0.0 could be 1.0.0-alpha.1. Then if another build is needed, it would become 1.0.0-alpha.2, and so on. Note that names cannot contain leading zeros, but hyphens are allowed in names for pre-release identifiers.</li> </ul>"},{"location":"semver/semantic-release/#how-does-it-work","title":"How does it work?","text":"<p>semantic-release uses the commit messages to determine the consumer impact of changes in the codebase. Following formalized conventions for commit messages, semantic-release automatically determines the next semantic version number, generates a changelog and publishes the release.</p> <p>By default, semantic-release uses Angular Commit Message Conventions. The commit message format can be changed with the preset or config options of the semantic-release/commit-analyzer and semantic-release/release-notes-generator plugins.</p> <p>The table below shows which commit message gets you which release type when semantic-release runs (using the default configuration):</p> Commit  message Release type fix(pencil): Fix Release feat(pencil): Feature Release perf(pencil): BREAKING CHANGE: The graphiteWidth option has been removed.The default graphite width of 10mm is always used for performance reasons. Breaking Release (Note that the BREAKING CHANGE:  token must be in the footer of the commit)"},{"location":"semver/semantic-release/#triggering-a-release","title":"Triggering a release","text":"<p>For each new commit added to one of the release branches (for example: master, next, beta), with git push or by merging a pull request or merging from another branch, a CI build is triggered and runs the semantic-release command to make a release if there are codebase changes since the last release that affect the package functionalities.</p> <p>semantic-release offers various ways to control the timing, the content and the audience of published releases. See example workflows in the following recipes:</p>"},{"location":"semver/semantic-release/#release-channels","title":"release channels","text":""},{"location":"semver/semantic-release/#pre-releases","title":"Pre-releases","text":"<p>We now decide to work on a future major release, which will be composed of multiple features, some of them being breaking changes. We want to publish our package for each new feature developed for test purpose, however we do not want to increment our package version or make it available to our users until all the features are developed and tested.</p> <p>To implement that workflow we can create the branch beta and commit our first feature there. When pushing that commit, semantic-release will publish the pre-release version 2.0.0-beta.1 on the dist-tag @beta. That allow us to run integration tests by installing our module with npm install example-module@beta. Other users installing with npm install example-module will still receive the version 1.0.0.</p> <p>The Git history of the repository is now:</p> <ul> <li>feat: initial commit # =&gt; v1.0.0 on @latest   | \\   |  * feat: first feature \\n\\n BREAKING CHANGE: it breaks something # =&gt; v2.0.0-beta.1 on @beta   We can continue to work on our future release by committing and pushing other features or bug fixes on the beta branch. With each push, semantic-release will publish a new pre-release on the dist-tag @beta, which allow us to run our integration tests.</li> </ul> <p>With another feature, the Git history of the repository is now:</p> <ul> <li>feat: initial commit # =&gt; v1.0.0 on @latest   | \\   |  * feat: first feature \\n\\n BREAKING CHANGE: it breaks something # =&gt; v2.0.0-beta.1 on @beta   |  * feat: second feature # =&gt; v2.0.0-beta.2 on @beta</li> </ul> <p></p>"},{"location":"semver/semantic-release/#maintenance-releases","title":"Maintenance releases","text":""}]}